#!/usr/bin/env python3
# -------------------------------------------------------------------------------
# MIT License
#
# Copyright (c) 2024 Advanced Micro Devices, Inc. All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# -------------------------------------------------------------------------------
#
# filter-dashboard - Generate dashboards with filtered-out panels and links
#
# Loads a dashboard in JSON format, transforms its panels and links, and prints
# it to stdout. This utility is meant to generate dashboard variants with
# certain subsets of panels/links. For example, standalone dashboards used
# without a resource manager can be automatically generated by removing panels
# that use `rmsjob_*` metrics.
#
# Filtering a dashboard involves:
#  1. Include panels whose titles match strings passed using the
#     `--include-title` argument.
#  2. Remove panels that use metrics that match strings passed using the
#     `--exclude-metric` argument.
#  3. Remove links with titles that match strings passed using the
#     `--exclude-link` argument.
#  4. Rewrite dashboard UID and update all URLs accordingly.

import argparse
import json
import re
import sys


def panel_contains_title(panel, pattern):
    title = panel.get("title", "")
    if re.search(pattern, title, re.IGNORECASE):
        return True
    return False


def panel_contains_expr(panel, pattern):
    for target in panel.get("targets", []):
        expr = target.get("expr", "")
        if len(pattern) and re.search(pattern, expr, re.IGNORECASE):
            return True
    return False


def convert_url(url, old, new):
    # Replace twice to change both uid and name.
    url = url.replace(f"-{old}", f"-{new}", 2)
    return url


def update_attribute(json_object, attribute, function, **kwargs):
    if isinstance(json_object, dict):
        for key, value in json_object.items():
            if key == attribute:
                json_object[key] = function(value, **kwargs)
            update_attribute(value, attribute, function, **kwargs)
    elif isinstance(json_object, list):
        for item in json_object:
            update_attribute(item, attribute, function, **kwargs)


parser = argparse.ArgumentParser()
parser.add_argument("-i", "--input", help="Input Grafana dashboard in JSON format", required=True, type=str)
parser.add_argument(
    "--include-titles", help="Include panels or rows with specific titles", nargs="*", required=False, default=[".*"]
)
parser.add_argument(
    "-m", "--exclude-metrics", help="Exclude panels with this metric", nargs="*", required=False, default=[]
)
parser.add_argument("-l", "--exclude-links", help="Exclude links with this name", nargs="*", required=False, default=[])
parser.add_argument("-n", "--replace-name", help="Replace dashboard title and uid", required=False, type=str)
parser.add_argument("--expand-rows", help="Expand all collapsible rows", action="store_true", default=False)
args = parser.parse_args()

# Patterns to include/exclude panels and links.
include_title = f"{'|'.join(args.include_titles)}"
exclude_metric = f"{'|'.join(args.exclude_metrics)}"
exclude_link = f"{'|'.join(args.exclude_links)}"

old = None
new = None
if args.replace_name:
    replace_pattern = r"([\w]+):([\w]+)"
    found = re.match(replace_pattern, args.replace_name)
    if not found:
        print(f"Error: replace argument should follow this pattern: OLD:NEW")
        sys.exit(1)
    old = found.group(1)
    new = found.group(2)

with open(args.input, "r") as f:
    dashboard = json.load(f)

# Update Grafana dashboard title and UID.
if args.replace_name:
    title = dashboard["title"]
    uid = dashboard["uid"]
    dashboard["title"] = title.replace(f"{old}", f"{new}")
    dashboard["uid"] = uid.replace(f"-{old.lower()}", f"-{new.lower()}")

# First pass to include/remove panels that contain matching pattern.
panels = dashboard.get("panels", [])
dashboard["panels"] = []
for panel in panels:
    if not "panels" in panel:
        if not panel_contains_expr(panel, exclude_metric) and panel_contains_title(panel, include_title):
            dashboard["panels"].append(panel)
    else:
        # Collapsible panels contain subpanels that also need to be evaluated.
        subpanels = panel["panels"]
        panel["panels"] = []

        for subpanel in subpanels:
            if not panel_contains_expr(subpanel, exclude_metric) and panel_contains_title(subpanel, include_title):
                panel["panels"].append(subpanel)

        # Keep all expanded row panels because there is no way to know if they
        # will be empty at this point.
        expanded = not panel["collapsed"] if "collapsed" in panel else False
        if expanded or len(panel["panels"]) > 0:
            dashboard["panels"].append(panel)

# Second pass over panels to remove empty expanded row panels.
panels = dashboard.get("panels", [])
dashboard["panels"] = []
for i, panel in enumerate(panels):
    expanded = not panel["collapsed"] if "collapsed" in panel else False
    last = True if i == len(panels) - 1 else False

    empty = False
    if expanded and last:
        empty = True
    elif expanded and not last:
        empty = panels[i + 1]["type"] == "row"

    if not empty:
        dashboard["panels"].append(panel)

# To expand all rows, we check for collapsed panels and manually move their
# subpanels to the root list of panels.
if args.expand_rows:
    panels = dashboard.get("panels", [])
    dashboard["panels"] = []
    for panel in panels:
        if "collapsed" in panel and panel["collapsed"] == True:
            subpanels = panel["panels"]
            panel["panels"] = []
            panel["collapsed"] = False
            dashboard["panels"].append(panel)
            for subpanel in subpanels:
                dashboard["panels"].append(subpanel)
        else:
            dashboard["panels"].append(panel)

links = dashboard.get("links", [])
dashboard["links"] = []
for link in links:
    title = link.get("title", "")
    if len(exclude_link) and re.search(exclude_link, title, re.IGNORECASE):
        continue
    dashboard["links"].append(link)

if args.replace_name:
    update_attribute(dashboard, "url", convert_url, old=old.lower(), new=new.lower())

print(json.dumps(dashboard, indent=2))
